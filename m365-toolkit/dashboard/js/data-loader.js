/**
 * ============================================================================
 * TenantScope
 * Author: Robel (https://github.com/Thugney)
 * Repository: https://github.com/Thugney/-M365-TENANT-TOOLKIT
 * License: MIT
 * ============================================================================
 *
 * DATA LOADER MODULE
 *
 * Loads all JSON data files from the dashboard/data/ directory into memory.
 * Provides a central data store accessible by all page modules.
 *
 * Usage:
 *   await DataLoader.loadAll();
 *   const users = DataLoader.getData('users');
 */

const DataLoader = (function() {
    'use strict';

    // ========================================================================
    // PRIVATE STATE
    // ========================================================================

    /**
     * Central data store holding all loaded JSON data
     * Key: data type name (e.g., 'users', 'devices')
     * Value: parsed JSON array/object
     */
    const dataStore = {
        users: [],
        licenseSkus: [],
        guests: [],
        mfaStatus: [],
        adminRoles: [],
        riskySignins: [],
        devices: [],
        autopilot: [],
        defenderAlerts: [],
        enterpriseApps: [],
        auditLogs: [],
        pimActivity: [],
        teams: [],
        sharepointSites: [],
        trendHistory: [],
        secureScore: null,
        appSignins: [],
        conditionalAccess: [],
        metadata: null
    };

    /**
     * Mapping of data types to their JSON file paths
     */
    const dataFiles = {
        users: 'data/users.json',
        licenseSkus: 'data/license-skus.json',
        guests: 'data/guests.json',
        mfaStatus: 'data/mfa-status.json',
        adminRoles: 'data/admin-roles.json',
        riskySignins: 'data/risky-signins.json',
        devices: 'data/devices.json',
        autopilot: 'data/autopilot.json',
        defenderAlerts: 'data/defender-alerts.json',
        enterpriseApps: 'data/enterprise-apps.json',
        auditLogs: 'data/audit-logs.json',
        pimActivity: 'data/pim-activity.json',
        teams: 'data/teams.json',
        sharepointSites: 'data/sharepoint-sites.json',
        trendHistory: 'data/trend-history.json',
        secureScore: 'data/secure-score.json',
        appSignins: 'data/app-signins.json',
        conditionalAccess: 'data/conditional-access.json',
        metadata: 'data/collection-metadata.json'
    };

    /** Track loading state */
    let isLoaded = false;
    let loadError = null;

    // ========================================================================
    // PRIVATE METHODS
    // ========================================================================

    /**
     * Fetches and parses a single JSON file.
     *
     * @param {string} url - Path to the JSON file
     * @returns {Promise<any>} Parsed JSON data, or empty array if fetch fails
     */
    async function fetchJSON(url) {
        try {
            const response = await fetch(url);

            if (!response.ok) {
                console.warn(`Failed to load ${url}: HTTP ${response.status}`);
                return null;
            }

            const text = await response.text();

            // Handle empty files
            if (!text || text.trim() === '') {
                console.warn(`Empty file: ${url}`);
                return null;
            }

            return JSON.parse(text);
        } catch (error) {
            console.warn(`Error loading ${url}:`, error.message);
            return null;
        }
    }

    /**
     * Formats a date string into a readable format.
     *
     * @param {string|null} dateString - ISO 8601 date string
     * @returns {string} Formatted date or '--' if null
     */
    function formatDate(dateString) {
        if (!dateString) return '--';

        try {
            const date = new Date(dateString);
            return date.toLocaleDateString('en-GB', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        } catch {
            return '--';
        }
    }

    // ========================================================================
    // PUBLIC API
    // ========================================================================

    return {
        /**
         * Loads all data files into the data store.
         * Shows loading overlay while fetching.
         *
         * @returns {Promise<boolean>} True if at least some data loaded
         */
        async loadAll() {
            console.log('DataLoader: Starting data load...');

            const loadingOverlay = document.getElementById('loading-overlay');
            if (loadingOverlay) {
                loadingOverlay.classList.remove('hidden');
            }

            try {
                // Check for bundled data first (generated by Build-Dashboard.ps1)
                // This bypasses fetch/CORS issues when opening via file:// protocol
                if (window.__M365_DATA) {
                    console.log('DataLoader: Using bundled data (data-bundle.js)');
                    Object.keys(dataStore).forEach(key => {
                        if (window.__M365_DATA[key] !== undefined) {
                            dataStore[key] = window.__M365_DATA[key];
                        }
                    });
                } else {
                    // Fallback: fetch JSON files individually (works over HTTP)
                    console.log('DataLoader: Fetching data files via HTTP...');
                    const loadPromises = Object.entries(dataFiles).map(async ([key, path]) => {
                        const data = await fetchJSON(path);
                        dataStore[key] = data || ((key === 'metadata' || key === 'secureScore') ? null : []);
                    });
                    await Promise.all(loadPromises);
                }

                // Post-process nested data structures
                // Teams data may come in nested format with metadata wrapper
                if (dataStore.teams && !Array.isArray(dataStore.teams) && dataStore.teams.teams) {
                    console.log('DataLoader: Extracting teams from nested structure');
                    dataStore.teams = dataStore.teams.teams;
                }

                // Log what was loaded
                Object.entries(dataStore).forEach(([key, data]) => {
                    console.log(`DataLoader: ${key} (${Array.isArray(data) ? data.length + ' items' : (data ? 'object' : 'null')})`);
                });

                // Check if any meaningful data was loaded
                const hasData = dataStore.users.length > 0 ||
                    dataStore.devices.length > 0 ||
                    dataStore.guests.length > 0 ||
                    (dataStore.teams && dataStore.teams.length > 0);

                isLoaded = true;
                loadError = null;

                // Update header with last updated time
                this.updateLastUpdated();

                if (!hasData) {
                    console.warn('DataLoader: No data found. Run Build-Dashboard.ps1 after data collection.');
                    return false;
                }

                console.log('DataLoader: All data loaded successfully');
                return true;

            } catch (error) {
                console.error('DataLoader: Failed to load data', error);
                loadError = error;
                return false;

            } finally {
                // Hide loading overlay with a slight delay for smooth transition
                setTimeout(() => {
                    if (loadingOverlay) {
                        loadingOverlay.classList.add('hidden');
                    }
                }, 300);
            }
        },

        /**
         * Gets data from the store by type.
         *
         * @param {string} type - Data type key (e.g., 'users', 'devices')
         * @returns {any} The requested data, or empty array if not found
         */
        getData(type) {
            if (!isLoaded) {
                console.warn('DataLoader: Data not yet loaded');
            }
            return dataStore[type] || [];
        },

        /**
         * Gets the collection metadata.
         *
         * @returns {object|null} Metadata object or null if not available
         */
        getMetadata() {
            return dataStore.metadata;
        },

        /**
         * Checks if data has been loaded.
         *
         * @returns {boolean} True if loadAll() has completed
         */
        isDataLoaded() {
            return isLoaded;
        },

        /**
         * Gets the last load error, if any.
         *
         * @returns {Error|null} The error or null
         */
        getLoadError() {
            return loadError;
        },

        /**
         * Updates the "Last updated" display in the header.
         */
        updateLastUpdated() {
            const lastUpdatedEl = document.getElementById('last-updated');
            const metadata = dataStore.metadata;

            if (lastUpdatedEl && metadata && metadata.endTime) {
                lastUpdatedEl.textContent = `Last updated: ${formatDate(metadata.endTime)}`;
            } else if (lastUpdatedEl) {
                lastUpdatedEl.textContent = 'Last updated: --';
            }
        },

        /**
         * Gets summary statistics from metadata.
         *
         * @returns {object} Summary object with counts
         */
        getSummary() {
            // Always compute from raw data to ensure all fields are present
            const users = dataStore.users || [];
            const guests = dataStore.guests || [];
            const devices = dataStore.devices || [];
            const alerts = dataStore.defenderAlerts || [];
            const licenseSkus = dataStore.licenseSkus || [];

            const compliantDevices = devices.filter(d => d.complianceState === 'compliant').length;
            const staleDevices = devices.filter(d => d.isStale).length;
            const mfaRegistered = users.filter(u => u.mfaRegistered).length;
            const noMfa = users.filter(u => !u.mfaRegistered).length;

            return {
                totalUsers: users.length,
                employeeCount: users.filter(u => u.domain === 'employee').length,
                studentCount: users.filter(u => u.domain === 'student').length,
                otherCount: users.filter(u => u.domain === 'other').length,
                disabledUsers: users.filter(u => !u.accountEnabled).length,
                inactiveUsers: users.filter(u => u.isInactive).length,
                noMfaUsers: noMfa,
                mfaRegisteredCount: mfaRegistered,
                mfaPct: users.length > 0 ? Math.round((mfaRegistered / users.length) * 100) : 0,
                adminCount: users.filter(u => u.flags && u.flags.includes('admin')).length,
                guestCount: guests.length,
                staleGuests: guests.filter(g => g.isStale).length,
                totalDevices: devices.length,
                compliantDevices: compliantDevices,
                nonCompliantDevices: devices.filter(d => d.complianceState === 'noncompliant').length,
                unknownDevices: devices.filter(d => d.complianceState !== 'compliant' && d.complianceState !== 'noncompliant').length,
                staleDevices: staleDevices,
                compliancePct: devices.length > 0 ? Math.round((compliantDevices / devices.length) * 100) : 0,
                activeAlerts: alerts.filter(a => a.status !== 'resolved').length,

                // Teams (governance-focused)
                totalTeams: (dataStore.teams || []).length,
                activeTeams: (dataStore.teams || []).filter(t => !t.isInactive).length,
                inactiveTeams: (dataStore.teams || []).filter(t => t.isInactive).length,
                ownerlessTeams: (dataStore.teams || []).filter(t => t.hasNoOwner).length,
                teamsWithGuests: (dataStore.teams || []).filter(t => t.hasGuests).length,
                publicTeams: (dataStore.teams || []).filter(t => t.visibility === 'Public').length,
                privateTeams: (dataStore.teams || []).filter(t => t.visibility === 'Private').length,

                // SharePoint
                totalSites: (dataStore.sharepointSites || []).filter(s => !s.isPersonalSite).length,
                activeSites: (dataStore.sharepointSites || []).filter(s => !s.isInactive && !s.isPersonalSite).length,
                inactiveSites: (dataStore.sharepointSites || []).filter(s => s.isInactive && !s.isPersonalSite).length,
                totalStorageGB: Math.round(((dataStore.sharepointSites || []).reduce((sum, s) => sum + (s.storageUsedGB || 0), 0)) * 10) / 10,
                groupConnectedSites: (dataStore.sharepointSites || []).filter(s => s.isGroupConnected).length,
                highStorageSites: (dataStore.sharepointSites || []).filter(s => (s.storageUsedGB || 0) >= 20).length,
                externalSharingSites: (dataStore.sharepointSites || []).filter(s => !s.isPersonalSite && s.hasExternalSharing).length,
                anonymousLinkSites: (dataStore.sharepointSites || []).filter(s => !s.isPersonalSite && (s.anonymousLinkCount || 0) > 0).length,
                noLabelSites: (dataStore.sharepointSites || []).filter(s => !s.isPersonalSite && !s.sensitivityLabelId).length,

                // License costs
                totalWasteMonthlyCost: licenseSkus.reduce((sum, l) => sum + (l.wasteMonthlyCost || 0), 0),
                totalWasteAnnualCost: licenseSkus.reduce((sum, l) => sum + (l.wasteMonthlyCost || 0), 0) * 12,
                totalEstimatedMonthlyCost: licenseSkus.reduce((sum, l) => sum + (l.estimatedMonthlyCost || 0), 0),
                currency: (licenseSkus.find(l => l.currency) || {}).currency || 'NOK'
            };
        },

        /**
         * Utility: Format date for display
         */
        formatDate: formatDate
    };

})();

// Export for use in other modules
window.DataLoader = DataLoader;
